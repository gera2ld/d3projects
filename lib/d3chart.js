// Generated by CoffeeScript 1.9.3
define(function(require, module, exports) {
  var defaults, utils;
  utils = require('./d3utils');
  defaults = {
    width: 260,
    height: 150,
    minX: null,
    maxX: null,
    minY: null,
    maxY: null,
    stroke: '#7ed321',
    threshold: 15,
    getText: null,
    fontSize: 12,
    rectWidth: 40,
    lineHeight: 1.5
  };
  return function(data, options) {
    var area, current, fillId, id, line, linearea, onmousemove, shadowId, showCircle, showText, svg, x, y;
    options = _.extend({}, defaults, options);
    if (options.minX == null) {
      options.minX = d3.min(data, function(d) {
        return d.x;
      });
    }
    if (options.minY == null) {
      options.minY = d3.min(data, function(d) {
        return d.y;
      });
    }
    if (options.maxX == null) {
      options.maxX = d3.max(data, function(d) {
        return d.x;
      });
    }
    if (options.maxY == null) {
      options.maxY = d3.max(data, function(d) {
        return d.y;
      });
    }
    svg = utils.newSVG().attr({
      'class': 'd3chart',
      width: options.width,
      height: options.height
    });
    id = utils.getId();
    fillId = "d3chart-fill-" + id;
    shadowId = "d3chart-shadow-" + id;
    utils.addShadowFilter(svg, shadowId);
    utils.addLinearGradient(svg, fillId, options.stroke);
    x = d3.scale.linear().domain([options.minX, options.maxX]).range([0, options.width]);
    y = d3.scale.linear().domain([options.minY, options.maxY]).range([options.height, 0]);
    data = _.map(data, function(d, i) {
      return {
        x: d.x,
        y: d.y,
        dx: x(d.x),
        dy: y(d.y),
        index: i
      };
    });
    linearea = {
      line: {},
      area: {}
    };
    line = d3.svg.line().x(function(d) {
      return d.dx;
    }).y(function(d) {
      return d.dy;
    }).interpolate('monotone');
    linearea.line.el = svg.append('path').attr({
      'class': 'd3chart-line',
      stroke: options.stroke,
      d: line(data)
    });
    area = d3.svg.area().x(function(d) {
      return d.dx;
    }).y0(options.height).y1(function(d) {
      return d.dy;
    }).interpolate('monotone');
    linearea.area.el = svg.append('path').attr({
      'class': 'd3chart-area',
      d: area(data)
    }).style('fill', "url(#" + fillId + ")");
    current = {
      show: function() {
        if (!this.hidden) {
          return;
        }
        this.hidden = false;
        this.circle.wrap.style('display', 'block');
        return this.tips.wrap.style('display', 'block');
      },
      hide: function() {
        if (this.hidden || linearea.line.hovered || linearea.area.hovered) {
          return;
        }
        this.hidden = true;
        this.circle.wrap.style('display', 'none');
        return this.tips.wrap.style('display', 'none');
      },
      circle: {
        wrap: svg.append('g').attr('class', 'd3chart-circle')
      },
      tips: {
        wrap: svg.append('g').attr('class', 'd3chart-text')
      }
    };
    current.circle.el = (function() {
      var wrap;
      wrap = current.circle.wrap;
      wrap.append('circle').attr({
        'class': 'd3chart-outer-circle',
        r: 3
      }).style('filter', "url(#" + shadowId + ")");
      wrap.append('circle').attr({
        'class': 'd3chart-inner-circle',
        r: 1,
        fill: options.stroke
      });
      return wrap.selectAll('circle');
    })();
    current.tips.rect = current.tips.wrap.append('rect').style('filter', "url(#" + shadowId + ")").attr({
      width: options.rectWidth,
      rx: 5,
      ry: 5
    });
    current.hide();
    showCircle = function(d) {
      var circle;
      circle = current.circle.el;
      return circle.attr({
        cx: d.dx,
        cy: d.dy
      });
    };
    showText = function(d) {
      var text, th, tips, tx, ty;
      text = (typeof options.getText === "function" ? options.getText(d) : void 0) || [d.y];
      th = options.fontSize * (options.lineHeight * (text.length + 1) - 1);
      current.tips.rect.attr('height', th);
      tx = utils.ensureRange(d.dx - 5, 0, options.width - options.rectWidth);
      ty = utils.ensureRange(d.dy - th - 10, 0, options.height - th);
      tips = current.tips.wrap;
      tips.attr('transform', "translate(" + tx + "," + ty + ")");
      tips.selectAll('text').remove();
      return tips.selectAll('text').data(text).enter().append('text').attr({
        x: options.fontSize * .5,
        y: function(d, i) {
          return options.fontSize * options.lineHeight * (i + 1);
        },
        'font-size': options.fontSize
      }).text(function(d) {
        return d;
      });
    };
    onmousemove = function() {
      var cir, dx;
      dx = d3.event.offsetX;
      cir = _.reduce(data, function(cir, d) {
        var delta;
        delta = Math.abs(d.dx - dx);
        if (delta < options.threshold && ((cir.delta == null) || cir.delta > delta)) {
          cir.delta = delta;
          cir.d = d;
        }
        return cir;
      }, {});
      if (cir.d) {
        showCircle(cir.d);
        showText(cir.d);
        return current.show();
      } else {
        return current.hide();
      }
    };
    linearea.line.el.on('mousemove', function() {
      linearea.line.hovered = true;
      return onmousemove();
    }).on('mouseleave', function() {
      linearea.line.hovered = false;
      return current.hide();
    });
    linearea.area.el.on('mousemove', function() {
      linearea.area.hovered = true;
      return onmousemove();
    }).on('mouseleave', function() {
      linearea.area.hovered = false;
      return current.hide();
    });
    return svg[0][0];
  };
});
