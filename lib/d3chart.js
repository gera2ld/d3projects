// Generated by CoffeeScript 1.9.3
(function() {
  define(function(require, module, exports) {
    var defaults, utils;
    utils = require('./d3utils');
    defaults = {
      width: 260,
      height: 150,
      minX: null,
      maxX: null,
      minY: null,
      maxY: null,
      stroke: '#7ed321',
      threshold: 15,
      getText: null,
      fontSize: 12,
      rectWidth: 40,
      lineHeight: 1.5
    };
    return function(data, options) {
      var area, current, fillId, id, line, shadowId, showCircle, showText, svg, x, y;
      options = _.extend({}, defaults, options);
      if (options.minX == null) {
        options.minX = d3.min(data, function(d) {
          return d.x;
        });
      }
      if (options.minY == null) {
        options.minY = d3.min(data, function(d) {
          return d.y;
        });
      }
      if (options.maxX == null) {
        options.maxX = d3.max(data, function(d) {
          return d.x;
        });
      }
      if (options.maxY == null) {
        options.maxY = d3.max(data, function(d) {
          return d.y;
        });
      }
      svg = utils.newSVG().attr({
        'class': 'd3chart',
        width: options.width,
        height: options.height
      });
      id = utils.getId();
      fillId = "d3chart-fill-" + id;
      shadowId = "d3chart-shadow-" + id;
      utils.addShadowFilter(svg, shadowId);
      utils.addLinearGradient(svg, fillId, options.stroke);
      x = d3.scale.linear().domain([options.minX, options.maxX]).range([0, options.width]);
      y = d3.scale.linear().domain([options.minY, options.maxY]).range([options.height, 0]);
      data = _.map(data, function(d, i) {
        return {
          x: d.x,
          y: d.y,
          dx: x(d.x),
          dy: y(d.y),
          index: i
        };
      });
      line = d3.svg.line().x(function(d) {
        return d.dx;
      }).y(function(d) {
        return d.dy;
      }).interpolate('monotone');
      svg.append('path').attr({
        'class': 'line',
        stroke: options.stroke,
        d: line(data)
      });
      area = d3.svg.area().x(function(d) {
        return d.dx;
      }).y0(options.height).y1(function(d) {
        return d.dy;
      }).interpolate('monotone');
      svg.append('path').attr({
        'class': 'area',
        d: area(data)
      }).style('fill', "url(#" + fillId + ")");
      current = {
        show: function() {
          if (!this.hidden) {
            return;
          }
          this.hidden = false;
          this.circle.wrap.style('display', 'block');
          return this.tips.wrap.style('display', 'block');
        },
        hide: function() {
          if (this.hidden) {
            return;
          }
          this.hidden = true;
          this.circle.wrap.style('display', 'none');
          return this.tips.wrap.style('display', 'none');
        },
        circle: {
          wrap: svg.append('g').attr('class', 'circle-wrap')
        },
        tips: {
          wrap: svg.append('g').attr('class', 'text-wrap')
        }
      };
      current.circle.el = current.circle.wrap.append('circle').attr('fill', options.stroke).style('filter', "url(#" + shadowId + ")");
      current.tips.rect = current.tips.wrap.append('rect').style('filter', "url(#" + shadowId + ")").attr({
        width: options.rectWidth,
        rx: 5,
        ry: 5
      });
      current.hide();
      showCircle = function(d) {
        var circle;
        circle = current.circle.el;
        return circle.attr({
          cx: d.dx,
          cy: d.dy
        });
      };
      showText = function(d) {
        var text, th, tips, tx, ty;
        text = (typeof options.getText === "function" ? options.getText(d) : void 0) || [d.y];
        th = options.fontSize * (options.lineHeight * (text.length + 1) - 1);
        current.tips.rect.attr('height', th);
        tx = utils.ensureRange(d.dx - 5, 0, options.width - options.rectWidth);
        ty = utils.ensureRange(d.dy - th - 10, 0, options.height - th);
        tips = current.tips.wrap;
        tips.style('transform', "translate(" + tx + "px," + ty + "px)");
        tips.selectAll('text').remove();
        return tips.selectAll('text').data(text).enter().append('text').attr({
          x: options.fontSize * .5,
          y: function(d, i) {
            return options.fontSize * options.lineHeight * (i + 1);
          },
          'font-size': options.fontSize
        }).text(function(d) {
          return d;
        });
      };
      svg.selectAll('path').on('mousemove', function() {
        var cir, dx;
        dx = d3.event.offsetX;
        cir = _.reduce(data, function(cir, d) {
          var delta;
          delta = Math.abs(d.dx - dx);
          if (delta < options.threshold && ((cir.delta == null) || cir.delta > delta)) {
            cir.delta = delta;
            cir.d = d;
          }
          return cir;
        }, {});
        if (cir.d) {
          showCircle(cir.d);
          showText(cir.d);
          return current.show();
        } else {
          return current.hide();
        }
      }).on('mouseleave', function() {
        return current.hide();
      });
      return svg[0][0];
    };
  });

}).call(this);
