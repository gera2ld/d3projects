// Generated by CoffeeScript 1.9.3
define(function(require, module, exports) {
  var defaults, utils;
  utils = require('./d3utils');
  defaults = {
    size: 200,
    r: null,
    checkData: null,
    delay: 500
  };
  return function(options) {
    var checkPath, circles, circles_wrap, clearPath, data, line, path, select, selected, svg, touch, updatePath;
    options = _.extend({}, defaults, options);
    svg = utils.newSVG().attr({
      width: options.size,
      height: options.size
    });
    data = _.map(_.range(9), function(d) {
      return {
        index: d,
        cx: ~~(((~~(d / 3)) * 2 + 1) * options.size / 6),
        cy: ~~((d % 3 * 2 + 1) * options.size / 6)
      };
    });
    if (options.r == null) {
      options.r = ~~(options.size / 12);
    }
    line = d3.svg.line().x(function(d) {
      return d.cx;
    }).y(function(d) {
      return d.cy;
    }).interpolate('linear');
    touch = {};
    selected = [];
    select = function(d) {
      if (d.selected) {
        return;
      }
      d.selected = true;
      return selected.push(d);
    };
    updatePath = function(pos) {
      var pathData;
      pathData = selected;
      if (pos) {
        pathData = pathData.concat({
          cx: pos[0],
          cy: pos[1]
        });
      }
      path.attr('d', line(pathData));
      return circles.classed('d3lock-selected', function(d) {
        return d.selected;
      });
    };
    clearPath = function(cb) {
      return _.delay(function() {
        _.each(selected, function(d) {
          return d.selected = false;
        });
        selected = [];
        touch.id = null;
        touch.freeze = false;
        circles_wrap.classed('d3lock-pass d3lock-fail', false);
        path.attr('d', '').classed('d3lock-pass d3lock-fail', false);
        circles.classed('d3lock-selected', false);
        return typeof cb === "function" ? cb() : void 0;
      }, options.delay);
    };
    checkPath = function() {
      var r;
      if ((touch.id == null) || touch.freeze) {
        return;
      }
      touch.freeze = true;
      updatePath();
      r = typeof options.checkData === "function" ? options.checkData(_.pluck(selected, 'index')) : void 0;
      if (r === true) {
        circles_wrap.classed('d3lock-pass', true);
        path.classed('d3lock-pass', true);
      } else if (r === false) {
        circles_wrap.classed('d3lock-fail', true);
        path.classed('d3lock-fail', true);
      }
      return clearPath();
    };
    circles_wrap = svg.append('g').attr('class', 'd3lock-circles');
    circles = circles_wrap.selectAll('circle').data(data).enter().append('circle').attr({
      r: options.r,
      cx: function(d) {
        return d.cx;
      },
      cy: function(d) {
        return d.cy;
      }
    }).on('touchstart', function() {
      var d, e;
      if ((touch.id != null) || touch.freeze) {
        return;
      }
      e = d3.event;
      e.preventDefault();
      touch.id = e.touches[0].identifier;
      d = d3.select(this).data()[0];
      return select(d);
    }).on('touchmove', function() {
      var d, pos, x, y;
      if (touch.freeze) {
        return;
      }
      pos = d3.touch(svg[0][0], touch.id);
      if (!pos) {
        return;
      }
      x = pos[0], y = pos[1];
      d = _.find(data, function(d) {
        return (x - d.cx) * (x - d.cx) + (y - d.cy) * (y - d.cy) <= options.r * options.r;
      });
      if (d) {
        select(d);
      }
      return updatePath(pos);
    }).on('touchend', checkPath);
    path = svg.append('g').append('path').attr('class', 'd3lock-path');
    return svg[0][0];
  };
});
